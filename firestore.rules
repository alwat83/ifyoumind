rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Ideas collection rules
    match /ideas/{ideaId} {
      // Anyone can read public ideas
      allow read: if resource.data.isPublic == true;
      
      // Only authenticated users can create ideas
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.authorId
        && validateIdeaData(request.resource.data);
      
      // Only the author can update core content fields. Clients cannot directly modify upvote arrays or counts; those are server-managed.
      allow update: if request.auth != null
        && request.auth.uid == resource.data.authorId
        && validateIdeaAuthorContentUpdate(request.resource.data, resource.data);
      
      // Author can delete own ideas; admins/moderators can moderate delete
      allow delete: if request.auth != null 
        && (request.auth.uid == resource.data.authorId || request.auth.token.admin == true || request.auth.token.moderator == true);
    }
    
    // Users collection rules (for user profiles)
    match /users/{userId} {
      // Users can read their own profile and public profiles
      allow read: if request.auth != null 
        && (request.auth.uid == userId || resource.data.isPublic == true);
      
      // Users can create their own profile
      allow create: if request.auth != null 
        && request.auth.uid == userId
        && validateUserData(request.resource.data);
      
      // Users can update their own profile (but cannot change uid, email, createdAt)
      allow update: if request.auth != null 
        && request.auth.uid == userId
        && validateUserUpdate(request.resource.data, resource.data);
      
      // Users can delete their own profile
      allow delete: if request.auth != null 
        && request.auth.uid == userId;
    }
    
    // Comments collection rules
    match /comments/{commentId} {
      // Anyone can read comments
      allow read: if true;
      
      // Only authenticated users can create comments
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.authorId
        && validateCommentData(request.resource.data);
      
      // Only the author can update their own comments
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.authorId
        && request.resource.data.content is string
        && request.resource.data.content.size() > 0
        && request.resource.data.content.size() <= 1000
        && (request.resource.data.keys().hasOnly(['content','authorId','authorName','ideaId','createdAt','updatedAt']) || request.resource.data.keys().hasOnly(['content','authorId','authorName','ideaId','createdAt']))
        && ( !('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp );
      
      // Only the author can delete their own comments
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.authorId;
    }

    // Bookmarks: user-centric document storing idea references (one doc per idea bookmarked)
    // Path: /users/{userId}/bookmarks/{ideaId}
    match /users/{userId}/bookmarks/{ideaId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId
        && request.resource.data.keys().hasOnly(['createdAt'])
        && request.resource.data.createdAt is timestamp;
      // No updates needed (immutable bookmark doc)
      allow update: if false;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Helper functions for data validation
    function validateIdeaData(data) {
      return data.keys().hasAll(['problem', 'solution', 'impact', 'authorId', 'authorName', 'createdAt', 'upvotes', 'upvotedBy', 'isPublic'])
        && data.problem is string && data.problem.size() > 0 && data.problem.size() <= 1000
        && data.solution is string && data.solution.size() > 0 && data.solution.size() <= 2000
        && data.impact is string && data.impact.size() > 0 && data.impact.size() <= 1500
        && data.authorId is string
        && data.authorName is string && data.authorName.size() <= 100
        && data.createdAt is timestamp
        && data.upvotes is number && data.upvotes >= 0
        && data.upvotedBy is list
        && data.isPublic is bool;
    }
    
    function validateIdeaAuthorContentUpdate(newData, oldData) {
      // Author can change textual fields and visibility; server (admin SDK) changes vote/trending fields.
      return validateIdeaData(newData)
        && newData.upvotes == oldData.upvotes
        && newData.upvotedBy == oldData.upvotedBy
        && newData.trendingScore == oldData.trendingScore
        && newData.lastActivity == oldData.lastActivity;
    }
    
    function validateUserData(data) {
      return data.keys().hasAll(['displayName', 'email', 'createdAt'])
        && data.displayName is string && data.displayName.size() > 0 && data.displayName.size() <= 100
        && data.email is string && data.email.size() > 3 && data.email.size() <= 320
        && data.createdAt is timestamp;
    }
    
    function validateUserUpdate(newData, oldData) {
      // Disallow changes to uid, email, createdAt but allow partial updates
      return !(newData.diff(oldData).changedKeys().hasAny(['uid', 'email', 'createdAt']));
    }
    
    function validateCommentData(data) {
      return data.keys().hasAll(['content', 'authorId', 'authorName', 'ideaId', 'createdAt'])
        && data.content is string && data.content.size() > 0 && data.content.size() <= 1000
        && data.authorId is string
        && data.authorName is string && data.authorName.size() <= 100
        && data.ideaId is string
        && data.createdAt is timestamp;
    }
  }
}

